MySQL索引

在我们开始描述索引类型之前，让我们快速回顾一下最常见的节点类型：

根节点 - 树结构中的最顶层节点
子节点 - 另一个节点（父节点）指向的节点
父节点 - 指向其他节点（子节点）的节点
叶节点 - 没有子节点的节点（位于树结构的底部）
内部节点 - 所有“非叶子”节点，包括根节点
外部节点 - 叶节点的另一个名称


二叉搜索树
![](https://iocaffcdn.phphub.org/uploads/images/201906/10/27353/xoTNbaE8h9.jpeg!large)

BST是二叉树，其中节点被排序。在上图中，我们看到节点X左侧的值小于X，节点X右侧的值更大。这就是任何BST的组织方式。


当我们在BST中搜索值时，我们从根节点开始，并将搜索到的值与根节点的值进行比较。如果搜索的值低于根值，我们将转到左子树。如果它更高，那么我们去右边的子树。如果我们找到了价值，我们就完成了。如果我们到达叶节点而没有找到我们的值，我们知道它不在我们的树中。





### B-树


在***B树***是大多数MySQL存储引擎的基本索引结构。B树中的每个节点具有*d*和*2d*值。每个节点中的值都已排序。每个节点具有*0*到*2d + 1*个子节点。每个子节点都附加在值之前，之后或之间。（在上图中，值“9”和“12”介于值“7”和“16”之间。）

B-Tree中的值以与二叉搜索树中的值类似的方式排序。值“X”左侧的子节点的值小于X; 值“X”右侧的子节点的值大于*X*（参见图片）。

与BST相比，B树是平衡树：树的所有分支具有相同的长度。

需要记住的重要一点是，**在B树结构中，每个节点都包含键值，指向值的指针**以及指向子节点的指针，子节点的值小于父节点中的值。当然，叶节点不指向任何子节点。

我们也可以在多个列上创建索引。如果我们在（`first_name`，`last_name`）对上创建索引，我们可以使用任一项进行搜索，但是当我们仅使用其中一个属性时，索引也会起作用。

最后，值得注意的是，当最常访问的数据更接近根节点时，B树将表现得更好。


B +树


![](https://iocaffcdn.phphub.org/uploads/images/201906/10/27353/Lx1su56jjw.png!large)

***B +树***结构是类似的B树结构。最重要的区别是：

-   内部节点只存储值; 它们不存储指向实际行的指针。叶节点存储值和行指针。这减少了内部节点的大小，允许在同一内存页面上存储更多节点。反过来，这增加了分支因子。随着分支因子的增长，树的高度会降低，从而导致更少的磁盘I / O操作。
-   B + Tree中的叶节点是链接的，因此我们只需一次传递就可以进行全扫描。当我们需要查找给定范围内的所有数据时，这非常有用。因为行指针存储在内部节点和叶节点中，所以这在B树中是不可能的。
-  在B +树结构中执行删除操作比在B树中更容易。这是因为我们不需要从内部节点中删除值。在B + Tree结构中，我们将重复相同的值; 在B树结构中，每个值都是唯一的。在B + Tree中，我们将在叶节点中存储一个值和一个数据指针，但该值也可以存储在内部节点中（用于指向子节点）。
-  B-Tree的优点是我们可以很快找到靠近根的值，而在B + Tree中，我们需要一直向下查看叶节点的任何值。
InnoDB存储引擎使用B + Tree结构来存储索引。




### 哈希索引


![](https://iocaffcdn.phphub.org/uploads/images/201906/10/27353/c0IIIT7Um8.png!large)




***散列索引***与散列技术直接相关。看看上面的图片。在左侧，我们看到用于查找数据的一组键值。在这种情况下，它们是数值。哈希函数用于计算存储实际数据桶的地址。这将为我们提供与每个键值相关的记录的位置。






> 索引是索引属性和指向记录的指针的结构和存储副本。
> 
```MySQL
SET @start_time = NOW();
 
SELECT book_details.book_title, COUNT(*) AS result
FROM book_details
GROUP BY book_details.book_title;
 
SET @end_time = NOW();
 
SELECT TIMEDIFF(@end_time, @start_time) AS difference;
```
要返回执行查询所需的时间，请在查询之前和之后立即设置*@start_time*和*@end_time*。他们的不同将告诉我们这项行动需要多长时间。

### 结论
当我们使用SELECT查询时以及需要ORDER返回值时，索引会显着提高性能。
当我们添加，更改或删除记录时，索引数据库需要时间来修改索引结构。



此过程需要在索引数据库上多花50％的时间。这突出了这样一个事实：当我们添加，更改或删除记录时，索引数据库需要时间来修改索引结构。

索引是非常强大的数据库结构。处理较小的数据集时，您可能不需要它们。但随着事情变得复杂，索引在整体表现中起着至关重要的作用。我们提出了三种常用的索引结构，我们已经考虑了它们的优缺点。在测试期间，我们已经证明索引在检索和更改数据时可以带来更好的性能。

